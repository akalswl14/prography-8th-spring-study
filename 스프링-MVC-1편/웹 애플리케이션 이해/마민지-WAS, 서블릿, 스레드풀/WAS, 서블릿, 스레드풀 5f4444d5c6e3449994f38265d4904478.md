# WAS, 서블릿, 스레드풀

## 웹서버와 WAS

- 웹서버 : 정적 리소스/파일 제공
- WAS : 어플리케이션 로직을 수행

## 서블릿

- 서블릿은 HTTP 요청 정보를 편리하게 사용(HttpServletRequest), HTTP 응답 정보를 편리하게 제공(HttpServletResponse) 하는 등의 기능을 제공해, 개발자가 비즈니스 로직 개발에 집중할 수 있다.
- HTTP 요청이 오면
    - WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체를 호출한다.
    - 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용한다.
    - 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력한다.
    - WAS는 Response 객체에 입력된 정보로 HTTP 응답 메시지를 생성해 응답한다.

### 서블릿 컨테이너

→ 서블릿을 지원하는 WAS

- 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리한다.
- 서블릿 객체를 싱글톤으로 관리한다.
- JSP도 서블릿으로 변환되어서 사용한다.
- 동시 요청을 위한 멀티 스레드 처리를 지원한다.

### 싱글톤 서블릿 객체

- 요청마다 객체를 생성하는 것은 비효율 적이므로, 싱글톤으로 관리한다.
- 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용한다.
- 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근한다.
- 공유 변수를 사용할 경우, 주의해야한다.
- 서블릿 컨테이너가 종료되면, 서블릿 객체도 함께 종료된다.

### 싱글톤 객체에 동시 요청이 가능한 이유

싱글톤 객체는 공유 메모리 영역인 힙에 저장된다.

스레드는 싱글톤 객체인 서블릿을 호출하고, 이때 service()라는 메소드를 실행한다. 

이때, 메소드 내부에서 사용되는 변수는 지역변수 이고, 이 지역변수는 스레드마다 독립적으로 할당된 스택 메모리에서 처리한다.

따라서, 동시 요청이 가능하다.

## 스레드와 서블릿

- 스레드는 서블릿을 호출한다.
- 스레드는 어플리케이션 코드를 하나하나 순차적으로 실행한다.
- 스레드는 한 번에 하나의 코드라인만 수행한다.

### 단일 스레드를 사용 + 단일 요청 처리

- 요청이 오면, WAS가 스레드를 하나 할당한다.
- 할당된 스레드가 서블릿을 호출한다.
- 서블릿이 응답을 WAS로 보낸다.
- 스레드는 휴식한다.

### 단일 스레드를 사용 + 다중 요청 처리

- 첫번째 요청을 WAS가 받아, 하나의 스레드에 할당한다.
- 해당 스레드는 서블릿을 호출하고, 그 서블릿이 처리하던 중 모종의 이슈로 처리가 지연되고 있다.
- 그때, 두번째 요청이 들어왔으나 스레드는 하나이므로, 스레드 할당은 대기 상태가 된다.

### 요청마다 스레드를 생성하여 처리

- 단일 스레드 사용 + 다중 요청 처리 상황에서, 두번 째 요청은 새로운 스레드에 할당된다.
- 새롭게 할당된 스레드가 서블릿을 호출해, 정상적으로 두번째 요청이 처리된다.
- 장점
    - 동시 요청 처리 가능
    - CPU, 메모리가 허용할 때까지 처리 가능
    - 하나의 스레드가 지연되어도, 나머지 스레드는 정상 작동한다.
- 단점
    - 스레드 생성 비용은 비싸다.
    따라서, 요청시마다 스레드 생성시 응답 속도가 느리다.
    - 스레드는 컨텍스트 스위칭 비용이 발생한다.
    - 스레드 생성에 제한을 두지 않아, 요청이 매우 많아졌을 때, CPU/메모리의 임계점을 초과해서 서버가 죽을 수 있다.

## 스레드 풀

**미리 만들어둔 스레드를 허용된 개수 안에서 사용하도록 제한하는 시스템**이며, 동시 요청을 안정적으로 처리해야하는 웹 서버에서 스레드 풀을 사용한다.

스프링 부트는 스레드 풀 구현체를 가지고 있는 톰캣의 서블릿 컨테이너를 내장하고 있다. 따라서, 스레드 풀에 대해, 최대 스레드 수, 최소 스레드 수, 최대 커넥션 수, 대기열의 크기를 설정해 보다 성능과 안정성을 개선할 수 있다.

### 단순하게 Thread를 사용하는 전략

요청이 올 때마다, 새로운 스레드를 생성해서 작업을 처리하고, 처리가 끝난 스레드는 없애는 방식으로 동작하는 자바 기반의 프로세스가 있다고 가정한다. 

**문제점**

1. 스레드를 생성비용이 커, 요청에 대한 응답시간이 증가한다.
    1. 자바에서는 One-to-One Threading Model을 쓰고 있어 유저 스레드당 꼭 하나의 OS 스레드를 연결한다.
    2. 새로운 스레드를 생성하는 작업은 OS 커널의 작업이 동반되므로 생성 비용이 큰 것이다.
    3. **작업을 요청할 때 마다 스레드를 생성하는 것은, 생성 비용까지의 오버헤드를 감당해야한다.**  
2. 스레드가 너무 많으면 여러 SideEffect가 발생한다.
    1. 프로세스의 처리 속도보다 빠르게 요청이 들어올 경우, 새로운 스레드가 계속 생성된다.
    2. 스레드가 많아질수록, 메모리를 차지해 **메모리 문제**가 발생할 수 있다.
    3. 스레드가 많아질 수록, 컨텍스트 스위칭이 더 자주 발생해, **CPU 오버헤드**가 발생할 수 있다.

![Untitled](WAS,%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B3%E1%86%AF%E1%84%85%E1%85%B5%E1%86%BA,%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%91%E1%85%AE%E1%86%AF%205f4444d5c6e3449994f38265d4904478/Untitled.png)

**스레드 풀의 구성요소**

1. 스레드 작업을 할 스레드들
2. 작업 큐 ( Work queue )

**스레드 풀의 작업 처리 순서**

1. 스레드 풀에 작업 처리 요청
2. 요청된 작업을 **작업 큐**에 보관
3. 작업큐의 작업들을 하나씩 스레드로 할당하여 스레드에서 작업 처리(스레드가 서블릿을 호출하면서 처리)
4. 클라이언트에 결과를 전달하고, **작업 처리를 완료한 스레드는 작업 큐로부터 그 다음 작업을 받아 처리**

**특징**

1. 메모리 문제와 CPU 오버헤드 방지 : 사용할 **스레드의 개수를 제한**한다.
2. 작업 마다의 **스레드 생성 비용이 없어** 요청 처리 시간이 감소한다 : 스레드를 미리 만들어 두며, 한 번 사용된 스레드가 작업이 끝난 이후에도 없어지지 않고, 재사용이 가능하다.

### SpringBoot 설정

1. `server.tomcat.threads.max`
    - 스레드 풀에서 사용할 수 있는 최대 스레드 개수 ( default : 200 )
    - 요청 수에 비해 너무 많게 설정할 경우 : 사용하지 않는 스레드가 많아 비효율적이다.
    - 요청 수에 비해 너무 적게 설정할 경우 : 동시 처리 요청수가 줄어들어, 평균 응답 시간과 tps ( 초당 트랜잭션 개수 ) 가 감소한다.
2. `server.tomcat.threads.min-spare`
    - 스레드 풀에서 사용할 수 있는 최소한의 스레드 개수 ( default : 10 )
    - 요청 수에 비해 너무 많게 설정할 경우 : 항상 유지할 스레드 수가 너무 많다. 메모리의 비효율이 발생한다.
    - 적절하게 설정할 경우 : 적은 수의 요청에서 새로운 스레드를 만들필요 없이 요청을 효과적으로 처리할 수 있다.
3. `server.tomcat.threads.max-connections`
    - 동시에 처리할 수 있는 최대 Connection의 수 ( default : 8192 )
    - Blocking IO의 경우 : 하나의 스레드에 하나의 커넥션이 연결되므로, 최대 스레드 수와 최대 커넥션 수가 같아야한다.
    - Non Blocking IO의 경우 : 하나의 스레드에 여러개의 커넥션이 연결되므로, 동시적으로 작업을 처리할 수 있다. 최대 스레드 수 < 커넥션 수 일때 효과적으로 처리한다.
    - Tomcat 8 이후는 Non Blocking IO를 채택하고 있다.
4. `server.tomcat.threads.accept-count`
    - max-connections 이상의 요청이 들어왔을 때 사용하는 대기열 queue 사이즈 ( default : 100 )
    - 너무 크게 설정할 경우 : 메모리 문제를 유발한다.
    - 너무 작게 설정할 경우 : 요청이 몰렸을 때 많은 요청을 거절한다.
    - 부적절하거나, 잘못된 요청이 한번에 너무 많이 들어와 서버에 장애를 발생시키는 것을 방지할 수 있다.

### 스레드 풀 적정 숫자를 찾기

- max thread 수가
    - 너무 낮으면, 응답이 지연된다.
    - 너무 높으면, CPU/메모리 임계점을 초과해 서버가 죽는다.
- 장애가 발생했을 때, 클라우드 기반이라면, 서버부터 늘리고 튜닝하는게 좋다.
- 스레드 풀의 적정 숫자는 성능 테스트를 통해 찾는다.
    - 실제 서비스와 유사하게 성능 테스트를 시도한다.
    - 툴 : 아파치 ab, jmeter, **nGrinder(영한픽), locust(영민픽**⭐**)**
    - 측정 이후 병목 포인트를 찾아 튜닝한다.